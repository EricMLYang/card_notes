---
tags:
  - charging-master
---
# Charge Schedule Algorithm - Handover

## 概述

此 Python 代码实现了一个用于电动巴士充电桩充电排程的算法，使用了遗传算法（Genetic Algorithm，GA）来优化充电计划。目标是在满足契约容量、充电时间段和各巴士电池电量等约束条件的情况下，优化一组巴士的充电计划。

代码结构清晰，主要由几个类和函数组成，每个部分都负责不同的功能。

---

## 主要组件

### 1\. `ChargingSchedule` 类

**功能：**

- **初始化**：设置充电频率、充电桩容量、巴士数量和数据路径等初始参数。

- **输入数据检查**：验证输入数据的完整性和正确性，包括请求 ID、时间段、契约容量、充电功率范围、当前电池电量和充电目标等。

- **时间段判断**：根据更新时间戳确定当前的充电时间段（夜间、日间或不可充电时间）。

- **结果处理**：将优化结果转换为所需的输出格式，并写入文件。

**关键方法：**

- `__init__()`

- `check_input_params()`

- `check_time_slots()`

- `input_params_return()`

- `result_to_file()`

- `run_status_return()`

### 2\. `GAOptimizer` 类

**功能：**

- **初始化**：设置遗传算法的参数，包括适应度函数、个体表示和遗传操作（选择、交叉、变异）。

- **目标函数**：定义适应度函数，最小化实际功率分配与目标功率分配之间的偏差，同时满足契约容量限制。

- **自定义变异**：实现自定义的变异函数，以调整个体基因（充电功率值）。

- **主优化循环**：运行遗传算法，通过指定的代数寻找最佳解决方案。

**关键方法：**

- `__init__()`

- `objective()`

- `random_value()`

- `custom_mutate()`

- `main()`

- `result()`

### 3\. `ScheduleRevised` 类

**功能：**

- **正值数据处理**：调整充电计划中超出需求的部分，减少多余的充电功率。

- **负值数据处理**：调整充电计划中不足的部分，增加所需的充电功率。

- **时间更新数组**：记录充电所需的时间调整。

**关键方法：**

- `__init__()`

- `process_positive_data()`

- `process_negative_data()`

### 4\. 辅助函数

- \*\*`check_interval()`\*\*：检查并调整时间间隔，确保每辆巴士在当前间隔内有足够的充电时间。

- \*\*`get_session_data()`\*\*：提取一组巴士的充电会话数据。

- \*\*`charging_phase()`\*\*：协调充电阶段，准备数据、运行优化器并处理结果。

- \*\*`main()`\*\*：协调整个流程，从读取输入数据到写入最终输出。

---

## 工作流程

1. **读取输入数据**：从命令行参数提供的 JSON 文件中读取输入数据。

2. **初始化**：创建 `ChargingSchedule` 的实例并检查输入参数。

3. **时间段判断**：确定当前时间属于夜间、日间还是不可充电时间段。

4. **充电阶段**：根据时间段进入不同的充电阶段：

   - **夜间充电**：可能涉及多个充电阶段，以达到不同的充电目标。

   - **日间充电**：通常只涉及一个充电阶段。

5. **优化**：对于每个充电阶段，执行以下步骤：

   - 准备充电会话数据。

   - 根据需要调整时间间隔。

   - 运行遗传算法优化器（`GAOptimizer`）。

   - 处理结果以确保满足所有约束条件（`ScheduleRevised`）。

6. **结果格式化**：将最终的优化计划转换为所需的 JSON 格式，并写入 `result.json` 文件。

7. **状态文件**：写入状态文件（`result.process`、`result.done`、`result.failed`），以指示进度或任何错误。

---

## 使用方法

1. **准备输入数据**：确保您有一个有效的 JSON 输入文件，其中包含所需的巴士和充电站属性数据。

2. **运行脚本**：从命令行执行脚本，传递输入文件的路径作为参数：

   ```bash
   python charging_schedule.py input.json
   ```

3. **监控输出**：检查与输入文件相同的目录中生成的状态文件和最终的 `result.json` 文件。

4. **解释结果**：`result.json` 文件包含优化后的充电计划，指定了每辆巴士的充电速率和计划。

---

## 重要细节

- **充电频率**：充电间隔基于一个频率参数（默认每 15 分钟），可根据需求调整。

- **契约容量**：任何时间点的总充电功率不应超过输入数据中指定的契约容量。

- **充电目标**：根据是夜间还是日间，应用不同的充电目标，确保巴士充电到适当的电量水平。

- **时间调整**：算法考虑需要提前出发的巴士，通过相应调整其充电计划。

- **约束处理**：遗传算法和后处理步骤确保所有充电计划都符合约束条件，例如每辆巴士的充电功率限制、总功率限制和时间段限制。

---

## 给初次使用者的提示

- **理解输入数据结构**：熟悉预期的输入 JSON 格式，包括巴士和充电站属性的字段。

- **检查依赖项**：脚本使用了 `deap`、`numpy`、`pandas` 等 Python 库，确保您的环境中已安装这些库。

- **根据需要修改参数**：您可以调整充电频率、遗传算法的种群大小、代数和目标函数中的权重等参数，以观察它们如何影响结果。

- **查看日志和输出**：使用代码中的打印语句和日志，了解数据在每个步骤是如何转换的。

---

## 结论

该脚本提供了一个使用遗传算法优化电动巴士充电计划的全面解决方案。通过理解上述结构和工作流程，您应该能够快速上手该代码并根据您的需求进行调整。

---

**备注**：如果您在运行或理解代码时遇到任何问题，建议逐步调试，并参考代码中的注释和打印输出，以深入了解每个部分的功能和执行流程。





## 基因演算法部分详解

### 概述

在这个电动巴士充电排程算法中，**`GAOptimizer`** 类实现了基因演算法（Genetic Algorithm，GA），用于优化充电计划。基因演算法是一种仿生优化算法，通过模拟自然选择和遗传机制，逐步演化出最优或近似最优的解决方案。

---

### 1\. **GAOptimizer 类的初始化**

```python
def __init__(self, interval:int, session_bus_num:int, npm:np.array, cs:ChargingSchedule, w1:int, w2:int):
```

- **参数说明：**

   - `interval`：时间间隔，表示优化过程中的时间段数量。

   - `session_bus_num`：当前充电会话中的巴士数量。

   - `npm`：每辆巴士需要充电的总功率目标数组。

   - `cs`：`ChargingSchedule` 类的实例，包含充电站和巴士的属性。

   - `w1` 和 `w2`：适应度函数中的权重，用于平衡不同的优化目标。

- **初始化过程：**

   - **定义适应度函数和个体：**

      ```python
      creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
      creator.create("Individual", list, fitness=creator.FitnessMin)
      ```

      - `FitnessMin`：定义了一个最小化的单目标适应度函数。

      - `Individual`：定义了个体的表示方式，这里每个个体是一个列表，代表了在所有时间间隔内，每辆巴士的充电功率分配。

   - **设置遗传算法的操作工具箱：**

      ```python
      self.toolbox = base.Toolbox()
      self.toolbox.register("attr_int", self.random_value)
      self.toolbox.register("individual", tools.initRepeat, creator.Individual, self.toolbox.attr_int, n=self.interval*self.session_bus_num)
      self.toolbox.register("population", tools.initRepeat, list, self.toolbox.individual)
      ```

      - `attr_int`：用于生成个体的基因值，即充电功率值。

      - `individual`：创建一个新的个体，由多个 `attr_int` 组成。

      - `population`：创建一个种群，由多个 `individual` 组成。

   - **注册遗传算法的操作：**

      ```python
      self.toolbox.register("evaluate", self.objective)
      self.toolbox.register("mate", tools.cxTwoPoint)
      self.toolbox.register("mutate", self.custom_mutate, indpb=0.1)
      self.toolbox.register("select", tools.selTournament, tournsize=3)
      ```

      - `evaluate`：适应度评估函数。

      - `mate`：交叉操作，这里使用了两点交叉（`cxTwoPoint`）。

      - `mutate`：突变操作，使用自定义的突变函数 `custom_mutate`。

      - `select`：选择操作，使用锦标赛选择（`selTournament`）。

---

### 2\. **目标函数（适应度函数）**

```python
def objective(self, individual):
    matrix = np.array(individual).reshape(self.interval, self.session_bus_num)
    row_sum = abs(np.sum(matrix, axis=1) - (self.cs.contract_limit - 20))
    column_sum = abs(np.sum(matrix, axis=0) - self.npm)
    return sum(row_sum) * self.w1 + sum(column_sum) * self.w2,
```

- **输入：**

   - `individual`：一个个体，表示一个可能的充电计划方案。

- **过程：**

   - **矩阵重塑：**

      - 将个体列表重塑为一个二维矩阵，行表示时间间隔，列表示巴士。

   - **计算行和（时间间隔的总功率）：**

      - `row_sum`：每个时间间隔的总充电功率与契约容量之差的绝对值。

   - **计算列和（每辆巴士的总充电量）：**

      - `column_sum`：每辆巴士的总充电量与目标充电量之差的绝对值。

   - **计算适应度值：**

      - 适应度值是行和与列和的加权和，权重由 `w1` 和 `w2` 控制。

- **目标：**

   - 最小化适应度值，即：

      - **使每个时间间隔的总充电功率尽可能接近（但不超过）契约容量。**

      - **使每辆巴士的总充电量尽可能接近其目标充电量。**

---

### 3\. **自定义的个体生成和变异函数**

#### 3\.1 **个体基因的初始化**

```python
def random_value(self):
    return np.random.choice([0, np.random.randint(self.cs.charging_power_min, self.cs.charging_power_max+1)])
```

- **功能：**

   - 随机生成一个基因值（充电功率），要么是 0，要么是在充电功率最小值和最大值之间的随机整数。

- **目的：**

   - **允许个体的基因值为 0，表示在某个时间间隔不为某辆巴士分配充电功率。**

   - **确保充电功率在充电桩的功率范围内。**

#### 3\.2 **自定义的突变函数**

```python
def custom_mutate(self, individual, indpb):
    for i in range(len(individual)):
        if random.random() < indpb:
            individual[i] = self.random_value()
    return individual,
```

- **参数：**

   - `individual`：需要突变的个体。

   - `indpb`：每个基因发生突变的概率。

- **过程：**

   - 遍历个体的每个基因，以概率 `indpb` 决定是否进行突变。

   - 如果突变，调用 `random_value()` 重新为该基因赋值。

- **目的：**

   - **引入随机性，避免陷入局部最优解。**

   - **保持基因值在合理范围内。**

---

### 4\. **主优化过程**

```python
def main(self):
    pop = self.toolbox.population(n=500)
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", np.mean)
    stats.register("min", np.min)
    pop, logbook = algorithms.eaSimple(pop, self.toolbox, cxpb=0.4, mutpb=0.3, ngen=100, stats=stats, halloffame=hof, verbose=True)
    return pop, logbook, hof
```

- **步骤：**

   1. **种群初始化：**

      - 生成初始种群，种群规模为 500。

   2. **统计和记录设置：**

      - 使用 `Statistics` 和 `HallOfFame` 来跟踪每一代的统计数据和最佳个体。

   3. **执行遗传算法：**

      - 使用 `algorithms.eaSimple` 进行进化：

         - `cxpb=0.4`：交叉概率为 0.4。

         - `mutpb=0.3`：突变概率为 0.3。

         - `ngen=100`：迭代 100 代。

- **输出：**

   - `pop`：最终的种群。

   - `logbook`：日志，包含每一代的统计信息。

   - `hof`：名人堂，存储了整个进化过程中的最佳个体。

---

### 5\. **结果处理**

```python
def result(self, output):
    result_df = pd.DataFrame(np.array(output).reshape(self.interval, self.session_bus_num))
    result_df[(result_df < self.cs.charging_power_min) | (result_df > self.cs.charging_power_max)] = 0
    # ... 输出和日志信息
    return result_df, result_df_sum
```

- **功能：**

   - 将最佳个体的基因表示转换为数据框，便于后续处理。

   - **将不在充电功率范围内的值设置为 0，确保功率值合法。**

   - 计算每个时间间隔和每辆巴士的总功率，以验证是否满足约束条件。

---

### 6\. **可能需要注意的地方和改进建议**

#### 6\.1 **适应度函数的设计**

- **问题：**

   - 适应度函数简单地将行和（时间间隔功率偏差）和列和（巴士充电量偏差）的绝对值加权求和。

   - **没有直接的约束机制来确保功率不超过契约容量或巴士充电功率在限制范围内，只是通过惩罚机制来间接实现。**

- **改进建议：**

   - **引入约束处理方法：**

      - **罚函数法**：对违反约束的解施加惩罚，提高其适应度值，使其在选择过程中被淘汰。

      - **修复操作**：在个体生成和变异后，直接修复不合法的基因值，使其满足约束条件。

      - **使用约束处理库**：如 `deap` 提供的 `tools.cxMessyOnePoint`，可以更好地处理约束问题。

#### 6\.2 **遗传算法参数的选择**

- **问题：**

   - 交叉概率（`cxpb=0.4`）和突变概率（`mutpb=0.3`）的选择可能不适合所有问题。

   - **种群规模、代数等参数的设置缺乏依据，可能需要根据问题规模进行调整。**

- **改进建议：**

   - **参数调优：**

      - **交叉和突变概率**：通常，交叉概率设置为较高的值（如 0.7~~0\.9），突变概率设置为较低的值（如 0.01~~0\.1）。

      - **种群规模和代数**：根据问题的复杂度和时间限制，调整种群规模和代数。

      - **使用参数优化技术**：如网格搜索或贝叶斯优化，自动寻找最优的参数组合。

#### 6\.3 **个体基因的表示和初始化**

- **问题：**

   - **个体基因值直接表示为充电功率，没有考虑到功率的离散性和连续性。**

   - **随机初始化可能导致初始种群质量较低，需要较多的代数才能收敛。**

- **改进建议：**

   - **改进初始化策略：**

      - **引入启发式的初始化方法**：根据巴士的充电需求和时间段，生成更合理的初始个体。

      - **增加多样性**：确保初始种群的多样性，避免过早收敛。

#### 6\.4 **自定义的突变和交叉操作**

- **问题：**

   - 自定义的突变函数简单地随机重置基因值，可能导致优化过程不稳定。

   - 使用标准的两点交叉（`cxTwoPoint`），可能不适合特定的编码方式。

- **改进建议：**

   - **设计更合适的突变和交叉操作：**

      - **基于问题特性的操作**：如交换、倒置、插入等操作，可能更适合调度问题。

      - **自适应突变**：根据当前代数或个体的适应度，动态调整突变概率。

#### 6\.5 **并行化和效率优化**

- **问题：**

   - **遗传算法的计算量较大，运行时间可能较长。**

- **改进建议：**

   - **并行化计算：**

      - 使用 `deap` 提供的并行化工具，如 `multiprocessing`，加速适应度评估过程。

   - **优化代码性能：**

      - **减少不必要的打印和日志输出**，提高运行效率。

      - **使用高效的数据结构和算法**，如避免在循环中进行大量的数据拷贝或转换。

#### 6\.6 **结果的合法性和可行性**

- **问题：**

   - **最终的充电计划需要满足所有的约束条件，包括契约容量、巴士充电功率范围、总充电量等。**

   - **目前的后处理步骤可能无法完全修复不合法的解。**

- **改进建议：**

   - **加强结果的验证和修正：**

      - **在适应度函数中引入更严格的约束处理，减少不合法解的产生。**

      - **在后处理步骤中，设计更完善的修正算法，确保结果可行。**

   - **多目标优化：**

      - **考虑使用多目标遗传算法（如 NSGA-II）**，同时优化多个目标，获得一组帕累托最优解。

---

### 总结

- **理解基因演算法的基本原理和参数设置对于优化充电计划至关重要。**

- **需要根据具体问题特点，调整适应度函数、遗传操作和参数，才能获得更好的优化结果。**

- **注意约束条件的处理，确保最终的充电计划合法且可行。**

- **在代码实现中，可以引入更多的优化策略和技术，以提高算法的效率和效果。**

---

### 建议

- **阅读相关文献和案例**，了解在类似调度问题中，基因演算法是如何应用和改进的。

- **对代码进行小规模的测试和调试**，观察参数变化对结果的影响。

- **持续优化和迭代**，根据实际运行情况，不断改进算法的性能。

---

**希望以上说明能帮助您更好地理解基因演算法在该充电排程中的应用，以及如何进一步改进。**






