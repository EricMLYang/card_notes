---
tags:
  - my-article
  - coding-agent
  - knowledge-management
---

# 我用 Coding Agent 管理知識庫的實驗

前陣子寫過一篇「AI 在我個人知識管理的角色」，
當時的結論是留在 Heptabase，
用 Obsidian 搭配 Gemini CLI 做進階處理，
結果才過幾個月，我就把 Heptabase 退訂了。

不是 Heptabase 不好，
而是 Coding Agent 的進化速度，
快到讓我覺得分散在兩個工具之間的摩擦力，
已經大過 Heptabase 白板帶來的好處了。


## 為什麼現在全押 Coding Agent

今年 Coding Agent 的能力提升，
不是「又多了一個好用的功能」那種程度，
而是整個工作模式被重新定義的等級。

以前 AI 輔助寫程式，就是幫你補 code、查 bug，
但現在的 Coding Agent 可以讀懂你整個 repo 的結構，
理解檔案之間的關係，
然後根據你用自然語言描述的需求，
自己去找檔案、讀內容、建新檔、改舊檔。

這跟以前的 Copilot 自動補全完全不是同一件事。

當我意識到這件事的時候，
我突然覺得：知識管理，不就是一種 repo 嗎？


## 我到底做了什麼

我目前的知識庫是一個 Obsidian Vault，
同時也是一個 Git Repo，
裡面有 200 多張 Zettelkasten 卡片、14 個索引分類、
草稿區、發佈區、問題意識區，
結構就是 Building a Second Brain 的 CODE 流程。

然後我用 Coding Agent 的 Skills 機制，
幫這個知識庫建了一套自動化流程，
每個 Skill 就像一個有 SOP 的小助手：

**卡片處理類**
- `break-cards`：丟一篇長文進去，自動拆成原子化卡片
- `link-cards`：幫新卡片找到知識庫裡最相關的既有卡片
- `process-inbox`：一鍵處理 Inbox → 拆卡片 → 建檔 → 更新索引 → 歸檔原文

**寫作類**
- `gather-cards`：給一個主題，自動從 200+ 張卡片裡撈出最相關的素材
- `write-pipeline`：從選題到發佈的全自動 pipeline，中間只有 3 個人工檢查點
- `resume-draft`：隨時可以看所有草稿的進度，從中斷的地方繼續

**資訊搜集類**
- `scout-news`：根據我的卡片、草稿、問題意識，自動上網搜相關新聞放進 Inbox

這些 Skill 不是什麼複雜的程式碼，
就是用 Markdown 寫的 SOP 文件，
告訴 Agent 遇到什麼情境該怎麼做、
用什麼順序執行、在哪裡暫停讓我決策。

但組合起來就形成了一個閉環：

```
搜集新聞 → Inbox → 拆卡片 → 建立知識 → 寫文章 → 萃取新卡片
    ↑                                                    |
    └────────────────────────────────────────────────────┘
```

知識越多，搜集越精準；寫越多文章，卡片越多；卡片越多，下一篇文章素材越豐富。


## 為什麼退訂 Heptabase

回到退訂 Heptabase 這件事。

上一篇文章我提到留在 Heptabase 的主因是：
「在 Heptabase 寫的東西，在我腦袋比較有留下痕跡。」

這個觀點我現在沒有改變，
手動整理確實對記憶有幫助。

但我後來發現，
Coding Agent 的互動過程其實也會在腦袋留下痕跡，
因為你要用自然語言去描述你想要什麼、
要審核 Agent 的產出、
要在檢查點做決策，
這整個過程其實就是一種主動思考。

而且 Coding Agent 在本地端運作，
我的所有資料都在我的電腦上，
不需要擔心某個 SaaS 明天改了 API 或是漲價。

最關鍵的是，
當我想要調整任何流程，
我只要改一個 Markdown 檔案就好，
不需要等官方開發新功能，
不需要用別人設計的 workaround。

這才是我最終決定全押的原因：
**控制權完全在我手上。**


## Coding Agent 趨勢下的一點觀察

我覺得 Coding Agent 這個趨勢有一件事被低估了，
就是它不只是給工程師用的。

我寫的這些 Skill 檔案，本質上就是 Markdown，
裡面沒有任何程式碼，
只有清楚的步驟、判斷邏輯、輸入輸出格式。

換句話說，
只要你能把工作流程講清楚，
Coding Agent 就能幫你執行。

這讓我想到之前寫的 AI Write Code Age 那篇文章，
提到 Vibe Coding 的概念，
其實知識管理也可以 Vibe，
你不需要會寫程式，
你只需要知道你想要什麼樣的知識處理流程。

而且隨著 Agent 越來越強，
你今天寫的 SOP，明天 Agent 會執行得更好，
你不需要改任何東西，
它自己就會進步。

這大概是我目前覺得最划算的投資：
花時間把流程想清楚，寫成 Skill，
然後坐等 Agent 能力升級帶來的免費紅利。


## 目前的限制

老實說也不是一切都很美好：

1. **Context Window 限制**：當卡片量繼續增長，Agent 不一定能一次讀完所有相關卡片，搜尋品質會受影響

2. **品質還是要人把關**：尤其是拆卡片的品質，如果不在檢查點認真看，會產出一堆低訊號的卡片

3. **初期建置成本**：把流程想清楚再寫成 Skill 其實花了不少時間，但我認為這是一次性成本

4. **離線限制**：Agent 需要呼叫 API，沒網路就沒辦法用


## 小結

從 Heptabase 到 Obsidian + Coding Agent，
對我來說不只是換工具，
而是從「在別人設計的框架裡整理知識」
變成「自己設計知識處理的自動化流程」。

這個轉變的核心邏輯很簡單：
Coding Agent 的趨勢是明確的，
能力只會越來越強，
而我現在投入的每一個 Skill、每一個流程設計，
都會隨著 Agent 進步而自動升值。

如果你也在思考知識管理工具的選擇，
我的建議是先問自己一個問題：

**你想要的是一個「更好的筆記軟體」，
還是一個「你能完全控制的知識處理系統」？**

如果是後者，
也許可以認真看一下 Coding Agent 這條路。
