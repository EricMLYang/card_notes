---
tags:
  - my-article
Checkbox 1: true
---
【從傳統資料倉儲到 Medallion 架構的演進】

---



▋ 資料倉儲的本質差異

資料倉儲和交易系統，從設計目標開始就走向不同的路。

OLTP（Online Transaction Processing）交易系統，

核心是寫入正確，

資料結構必須正規化，

避免任何重複，

每一筆交易都不能出錯。



但 OLAP（Online Analytical Processing）分析系統，

讀取量大，所以重點轉向讀取速度，

其他可以妥協，

使用大表、反正規化、寬表、Star Schema，

資料可以重複，只要查詢夠快。

—



▋ 傳統 ETL 的三階段邏輯

傳統資料倉儲建立在 ETL，

就次  Extract → Transform → Load 之上，

這是成熟的三段式流程。



第一階段是 Staging Layer 落地層，

從 API、Database、File 等各種來源抽取資料，

這些資料原封保存，

格式雜亂、來源不一致都無所謂，

目的只有確保資料不遺失。



第二階段是 Integration Layer，

清洗與標準化層，

這裡才是真正有大量工作的地方，

清洗錯誤、統一格式、建立 Key Mapping、整合多來源，

還要處理 SCD（Slowly Changing Dimensions），

追蹤歷史變化，

核心任務是把資料變成可以分析的統一格式。



第三階段是 Presentation Layer，呈現層。
Star Schema、Data Marts、聚合表，

全部為了讓分析師能快速查詢，

針對讀取效能徹底最佳化，

直接支援商業決策。



不論你用的是舊的數倉還是新的 Lakehouse，

這三段 transformation 的本質未變。

---

—

▋ Star Schema 的設計哲學

Star Schema 的結構簡單，

就是事實表加維度表。



事實表（Fact Table）記錄可量測的業務事件，

例如：

．商店的每一筆交易：銷售金額、數量、時間戳，

．車輛的每一次位置更新：經度、緯度、速度、時間戳．

 ．AI Camera 的每一次偵測：人數、停留時間、時間戳，

 這些資料會不斷堆積，這就是事實。



維度表（Dimension Table）則描述「事件發生的背景」，

 ．店鋪維度：店名、地址、營業時間。有新店才新增一筆，

．車輛維度：車牌號碼、車型、出廠日期。有新車才新增一筆，

． Camera 維度：設備編號、安裝位置、規格。有新裝才新增一筆，

但維度不是靜止的，它們會慢慢改變。
店長換人、車子轉手、Camera 升級韌體。

—



▋SCD（Slowly Changing Dimensions）

維度表可以分成幾種，

SCD Type 1 直接覆蓋：

舊資料消失，只保留最新狀態，

商品名稱改了就直接更新，

歷史不見了。



SCD Type 2 新增一筆：最常用的策略

每次變更都新增一行，完整保留歷史軌跡，

 用「生效日期」、「失效日期」、「是否為目前版本」標記狀態，

 客戶換地址時，舊地址標記「已失效」，新增一筆新地址。



SCD Type 3 新增欄位：在同一筆資料裡增加欄位記錄前一個狀態。
只能記有限歷史，通常就是一個 previous value。
適合只需要「目前值」加「上一個值」的情境。



Kimball 提出的「一致性維度」 ，

進一步讓不同部門、不同報表共用同一份維度表，

時間維度表、店鋪維度表，全公司只有一份，

這樣各部門的分析結果才能對得起來，不會各說各話。

---

—

▋ 從 ETL 到 ELT 的典範轉移

傳統 ETL 的邏輯是，

先清洗、轉換，最後才載入資料倉儲。，

資料倉儲裡只存「乾淨的資料」，

這個設計的問題在於，

Transform 的邏輯寫死在流程裡，

 需求一改整個流程要重跑，

 原始資料可能已經被丟棄，無法回頭。



大數據時代帶來了 ELT：Extract → Load → Transform。
先把所有原始資料載入 Data Lake，

不管它乾不乾淨。
之後再根據需求進行 Transform。

—



▋用儲存間換取彈性

這個轉變的核心是：保留原始資料，

 隨時可以重新處理，彈性大幅提升，



大數據架構通常分成三層。

．資料來源層：所有產生資料的系統與設備。

 CSV、JSON、Database、API，格式完全不一致。 批次、串流、即時，頻率也完全不同。



．資料傳遞與整合平台層：負責把資料運進來、整合起來。，

Spark、Airflow、Kafka、Fivetran、DBT，工具選擇很多。

 這層的技術複雜度最高，決策最難下。



．資料消費與應用層：BI 報表、機器學習、AI 模型、即時分析，

每個商業問題需要不同技術組合，

這層的技術種類最多。

---

—

▋ Medallion 架構的核心問題

Lakehouse 時代採用 ELT 模式，

所有原始資料先進來，不管乾淨與否，

但這讓資料使用者不知道資料的狀，

 這份資料乾淨嗎？可以信任嗎？經過什麼處理？



Medallion Architecture（金銀銅架構）就是為了解決這個問題，

它的核心價值是：給每一份資料貼上「成熟度標籤」。



．Bronze Layer（銅表）：

是原始落地層，

 原封不動保存所有來源資料，

錯誤、缺漏、格式不一致全部保留，

就像便利商店 POS 機原始吐出的 JSON 檔案，

錯誤交易、重複資料、不一致格式，通通都在．

時間可能是 "2024/01/01"，

也可能是 "01-01-2024"，完全沒統一。



．Silver Layer（銀表）是清洗標準化層，

清除錯誤、去除重複、統一格式，

日期、ID、命名全部標準化，

補齊缺失值、建立資料關聯。

商品編碼轉換為可讀名稱，

 店鋪資訊補齊。



．Gold Layer（金表）是業務聚合層，

 針對特定業務問題預先彙總，

可直接用於 BI 報表或決策，

 查詢效能徹底最佳化。

「每日各店銷售額彙總表」、「商品類別週報表」、「熱門商品 Top 10 排行」。 這些都是 Gold Layer 的產出。

—

---

▋ Medallion 的五大核心價值

1\.提供情境（Context）:

 使用者立刻知道資料處於什麼成熟度，

Bronze 代表原始、Silver 代表可信、Gold 代表可決策。



2\.容錯與重跑能力

．假設 Silver 的清洗邏輯有 Bug，

已經跑了半年， 因為保留了 Bronze，

可以修改程式碼，從 Bronze 重新回放過去半年資料。 

錯誤可以被修復，不是永久性的損失。



3\.，支援 Time Travel 和 Audit Trail，

可以追溯「三個月前這筆資料長什麼樣子」，

 符合法規稽核要求。





4\.團隊協作:

資料工程師負責 Bronze 到 Silver 的清洗轉換

 分析師、資料科學家從 Silver 建立 Gold，

不同技能的人專注不同層，分工明確，效率更高。

---

—

▋ 架構演進的邏輯必然性

．傳統 ETL 時代，

資料進來前必須決定「要不要、怎麼清」，

Staging → Integration → Presentation 三階段明確切分，

資料倉儲很乾淨，

但改需求很痛苦，

原始資料可能永久丟失。

\
大數據 ELT 時代，先全部載入，

之後再決定怎麼用，

保留原始資料，彈性大幅提升，

但使用者不知道資料品質狀態，這是新的問題。



Medallion 架構結合了兩者的優點：

Bronze 保留原始資料，

Silver 提供標準化資料，

Gold 支援業務決策。

每一份資料都帶有履歷：

從哪來、經過什麼處理、現在準備好做什麼。
這不是刻意設計的複雜性，

而是從歷史演進中走出來的必然選擇。


