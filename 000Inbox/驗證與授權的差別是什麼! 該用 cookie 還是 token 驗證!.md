---
tags:
  - backend
---
# 驗證與授權的差別是什麼? 該用 cookie 還是 token 驗證?

󠀠󠀠

很多網站都有的登入這件事。所謂的註冊與登入，是從產品、使用者的角度來看，如果從技術的角度看，登入在做的事情其實是驗證 (authentication) 與授權 (authorization)。

󠀠

當一個使用者登入後 (不論透過帳號密碼，或者透過第三方登入、Magic Links 等方式)，系統驗證了你的身分，並且根據你有的權限，讓你能做相應的操作。

󠀠

驗證與授權的區別，是很多初階工程師面試會問的。

󠀠

### 驗證 (authentication) 

- 驗證你的身分，白話來說就是讓系統知道你是你，而不是別人。舉例來說，在登入時輸入帳號密碼，即是一種驗證你確實是你的方式

- 比較注重資安的系統，通常會有多層的驗證 (例如常見的二階段驗證 2FA，會要求你輸入帳號密碼外，會有像是收簡訊碼等額外個步驟，來驗證你的身份)。

󠀠

### 授權 (authorization) 

- 涉及你有什麼權限。在系統確認你確實是你後，系統會需要進一步判斷你有什麼權限，並基於你有的權限，開放讓你能做不同的操作。

- 以文件系統來說，不同職級的人可能會有不同的權限，例如執行長有最大的權限，所以什麼文件都能閱覽，但一位剛進公司的初階工程師的權限有限，會有部分文件沒辦法閱覽。

󠀠



面試常會問的問題，在網頁開發中，如果要保持使用者的登入狀態，讓使用者不用每次到網站就要重新輸入密碼，該怎麼做? 

󠀠

- 一般網站做驗證會區分成 session-based 與 token-based 兩種方式

- 抽象化一個層次來看，這兩種方式分別會是有狀態 (stateful) 以及無狀態 (stateless)，而這兩種取向各有優缺。

### session-based 

- 有狀態的驗證方式

- 伺服器端會創建 session，客戶端會記下 session id，每次請求帶上 session id (一般透過 cookie ), 然後伺服器端收到後檢查這個 session 是否還是有效狀態，如果是的話就完成驗證

- 一般來說，有狀態的驗證會比較安全，因為伺服器端可以管理狀態，所以如果被駭客攻擊，伺服器端可以主動把 session 設成無效，來避免被攻擊。

### token-based

- 無狀態的驗證，一般透過 token 來做到，透過加密演算法生成的 token，可以直接驗證 (例如透過 JWT)

- 無狀態驗證的好處是，速度會快非常多。以一般 token 的 decode 來說，大約 1 毫秒就完成；但是查看 session 會需要去資料庫撈資料來比對，通常至少 20 - 30 毫秒。當量大起來，兩者在耗時的差異會變很明顯。

󠀠

目前業界主流會採用混合作法 (hybrid approach)，也就是無狀態搭配有狀態，讓兩者的優點都能兼顧到。具體的作法，是現在常見的 access token 搭配 refresh token 的方式。

󠀠

讓 access token 是無狀態，所以能維持速度快的優勢；同時設定短過期時間 (例如每分鐘或每小時過期)，過期後用 refresh token 去換新的 access token。由於 refresh token 的過期時間會設定比較長，使用者不會因為 access token 過期就要重新登入，是直到 refresh token 過期才要重新登入。

󠀠

拿 refresh token 去換新的 access token 這件事情是有狀態的，因此後端就可以去控制，當遇到安全性問題 (例如被攻擊)，就可以把 token 變無效。這種混合的搭配方式，就能維持快速又安全。



## \[ JWT 是如何實作「數位簽名」的？\]

- 數位簽名 (signature) 可以說是鞏固 JWT 不會被駭客竄改的神設計

- JWT 通常就是用來「傳遞身份認證的數據」，並且 JWT 會由三個部分所組成，分別是：header、payload 以及 signature，並且每個部分所負責的功能都不同

- 數位簽名的運作邏輯:

   - 如果要實作 JWT 的數位簽名的機制，最常見的做法是使用「非對稱加密」來實作，所以在實作前，後端需要先生成一組「公鑰」和「私鑰」出來，等等就會使用這兩組密鑰來搭配實作「數位簽名」的功能。 而當後端生成好一組公鑰和私鑰之後，就可以開始來進行 JWT 的生成了

   - 在非對稱加密中，公鑰是公開的、可以廣發給所有人，私鑰則是私有的，要自己保管好，絕對不可以洩漏。並且使用公鑰來加密的數據，只能使用私鑰來解密；使用私鑰來加密的數據，只能使用公鑰來解密。 󠀠󠀠 

### JWT 的生成

1. 在生成 JWT 時，首先後端要先根據自己的商業邏輯，填上 header 和 payload 中的值。所以像是在下方的 payload 中，我就填上了 {"sub":"123", "name":"古古"...} 的資訊，用來表示這個 JWT 中所裝的使用者資訊，是名叫「古古」的使用者資訊。

2. 而當寫好 header 和 payload 中的值之後，此時後端需要對 header + payload 的值 Hash 一下（此處使用的是 SHA-256 Hash 演算法），所以此時就會計算出 header + payload 被 Hash 過後的結果，即是 srtp3k。

3. 接著後端要使用「私鑰」，將這個 hash value srtp3k 加密，因此就會得到一個加密過後的結果 ap9fPl...。

4. 而當後端產生出 ap9fPl... 這個加密過後的結果之後，「後端必須將這個值放在 JWT 中的 signature 的欄位中」，因此最後後端傳送出去的 JWT 結果，就會在 signature 的部分填上 ap9fPl... 的加密過後的值。 󠀠󠀠 

### JWT 的驗證

- 而當前端後續拿著這個 JWT 來請求 api 時，我們身為後端，就必須要驗證這個 JWT 的正確性（即是是否有被駭客竄改過），而要驗證 JWT 的正確性，就是「去檢查其中的 signature 的值」就可以了。

- 舉例來說，當前端拿著剛剛的那一個 JWT 來請求 api 時，這時候我們身為後端，必須要計算出 header + payload 的 Hash 值（即為 srtp3k）

- 這時後端只要使用「公鑰」將 signature 解密，然後比較一下「當初所計算出來 Hash 的值」和「現在所計算出來的 Hash 值」是否一樣，就可以知道此 JWT Token 是否有被竄改過了！


